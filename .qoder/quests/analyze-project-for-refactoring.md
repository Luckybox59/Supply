# Анализ проекта Parser для глобального рефакторинга

## Обзор проекта

**Parser** — это GUI-приложение на Python для автоматизированной обработки счетов и заявок в форматах PDF и Excel. Система использует LLM через OpenRouter для извлечения структурированных данных, сравнивает заявки со счетами и отправляет результаты по электронной почте.

### Текущее состояние
Проект уже прошел один цикл рефакторинга (см. REFACTORING_REPORT.md), но анализ кода показывает нарушения принципов из conventions.mdc:

## Основные проблемы архитектуры

### 1. Нарушение принципа KISS
- **Проблема**: Сложная многослойная архитектура с избыточными абстракциями
- **Пример**: 7 различных пакетов для простой задачи обработки файлов
- **Решение**: Упростить до 3-4 основных модулей

### 2. Избыточная сложность (Over-Engineering)
- **Проблема**: Батчинг, пулы воркеров, сложная система retry для простого case
- **Пример**: `FileBatchProcessor`, `OCRWorkerPool` для обработки 1-5 файлов
- **Решение**: Убрать избыточные абстракции, оставить простую последовательную обработку

### 3. Нарушение принципа DRY
- **Проблема**: Дублирование логики в разных слоях
- **Пример**: Валидация в GUI, models, parsers
- **Решение**: Централизовать валидацию в одном месте

### 4. Слишком длинные функции
- **Проблема**: GUI файл 972 строки, pipeline.py 735 строк
- **Пример**: Методы в gui.py превышают 40 строк
- **Решение**: Разбить на функции до 40 строк максимум

### 5. Сложная структура каталогов
```
Текущая (слишком сложная):
├── core/           # 4 файла
├── parsers/        # 5 файлов 
├── llm/           # 3 файла
├── email_service/ # 3 файла
├── services/      # 3 файла
├── models/        # 2 файла
├── gui/           # 2 файла + основной gui.py
└── tests/         # 5 файлов

Предлагаемая (простая):
├── lib/           # Основная логика
├── gui/           # GUI компоненты
└── tests/         # Тесты
```

## Предлагаемая новая архитектура

### Принципы рефакторинга
1. **KISS**: Максимально простая структура
2. **Функциональный подход**: Простые функции вместо сложных классов
3. **Одна ответственность**: Каждый модуль делает одну вещь хорошо
4. **Читаемость**: Код как документация

### Новая структура модулей

```
Parser/  # Корень проекта
├── settings.json           # Не секретные настройки (коммитится в Git)
├── secrets.json            # Конфиденциальные данные (в .gitignore)
├── gmail_credentials.json  # OAuth2 credentials для Gmail API (в .gitignore)
├── gmail_token.json        # Access token Gmail API (создается автоматически)
├── supplier_replacements.json  # Словарь замен поставщиков
├── requirements.txt        # Зависимости
├── Шаблон отчета для Parser.md.j2  # Jinja2 шаблон
│
lib/                     # Основная логика
├── __init__.py
├── config.py               # Лоадер конфигурации (существующий)
├── file_parser.py          # PDF + Excel парсинг (объединяем parsers/)
├── text_processor.py       # Очистка + OCR (упрощаем)
├── llm_client.py           # LLM запросы (упрощаем llm/)
├── email_provider.py       # Определение почтового провайдера (Gmail vs другие)
├── gmail_service.py        # Gmail API клиент (новый)
├── email_sender.py         # Унифицированная отправка почты (упрощаем email_service/)
├── email_searcher.py       # Унифицированный поиск писем (упрощаем email_service/)
├── data_processor.py       # Обработка данных (упрощаем services/)
└── utils.py                # Утилиты (из core/)

gui/                     # GUI компоненты
├── __init__.py
├── main_window.py          # Основное окно (разбиваем gui.py)
├── file_widgets.py         # Виджеты выбора файлов
├── email_widgets.py        # Виджеты почты
└── report_widgets.py       # Виджеты отчетов

tests/                   # Тесты
├── test_parsers.py
├── test_processing.py
├── test_gmail_api.py       # Тесты Gmail API интеграции
└── test_integration.py
```

### Новые компоненты для Gmail API

#### lib/email_provider.py
```python
def detect_email_provider(email: str) -> str:
    """Определяет провайдера по email адресу."""
    
def is_google_account(email: str) -> bool:
    """Проверяет, является ли аккаунт Google аккаунтом."""
    
def get_email_client(email: str) -> EmailClient:
    """Возвращает подходящий клиент для работы с почтой."""
```

#### lib/gmail_service.py
```python
class GmailService:
    """Gmail API клиент для отправки и поиска писем."""
    
    def __init__(self, credentials_path: str):
        """Инициализация с OAuth2 credentials."""
        
    def authenticate(self) -> bool:
        """OAuth2 аутентификация."""
        
    def send_email(self, message: dict) -> str:
        """Отправка письма через Gmail API."""
        
    def search_emails(self, query: str) -> list:
        """Поиск писем через Gmail API."""
        
    def send_reply(self, original_id: str, reply: dict) -> str:
        """Отправка ответа на существующее письмо."""
```

#### Обновленные модули

**lib/email_sender.py** - унифицированный интерфейс:
```python
class UnifiedEmailSender:
    """Унифицированный отправитель писем."""
    
    def send_email(self, email_data: dict) -> bool:
        """Отправляет письмо выбирая оптимальный метод."""
        
    def send_reply(self, reply_data: dict) -> bool:
        """Отправляет ответ на письмо."""
```

**lib/email_searcher.py** - унифицированный поиск:
```python
class UnifiedEmailSearcher:
    """Унифицированный поисковик писем."""
    
    def search_emails(self, criteria: dict) -> list:
        """Ищет письма используя оптимальный метод."""
```

### Упрощения

#### 1. Убрать избыточные абстракции
- **Удалить**: Батчинг, пулы воркеров, сложный retry
- **Оставить**: Простую последовательную обработку с базовым retry
- **Причина**: Для 1-5 файлов параллелизм не нужен

#### 2. Объединить похожие модули
- **parsers/ → file_parser.py**: Один модуль для PDF и Excel
- **llm/ → llm_client.py**: Простой клиент без сложных промптов
- **email_service/ → email_sender.py**: Только отправка, без сложной логики

#### 3. Упростить GUI
- **Разбить gui.py на 4 файла** по 200-250 строк каждый
- **Убрать сложную логику** из GUI в lib/
- **Простые функции** вместо методов классов

#### 4. Упростить конфигурацию
- **Оставить config.py как есть** — он уже хорош
- **Использовать отдельные файлы** в корне проекта:
  - **settings.json** — не секретные настройки
  - **secrets.json** — конфиденциальные данные
- **Убрать сложные настройки** OCR и батчинга
- **Базовые настройки** для простой работы

#### Структура settings.json (не секретные настройки)
```json
{
  "to_email_default": "user@example.com",
  "subject_suffix_peredelka": "(#ПЕР)",
  "folder_paid_label": "Оплата",
  
  "gmail_credentials_path": "gmail_credentials.json",
  "gmail_token_path": "gmail_token.json",
  "use_gmail_api": true,
  "google_domains": ["gmail.com", "googlemail.com"],
  
  "email_search_limit": 50,
  "email_search_days": 30,
  
  "report_template_path": "Шаблон отчета для Parser.md.j2",
  "poppler_path": "D:/Program files/poppler-24.08.0/Library/bin",
  
  "log_level": "INFO",
  "gui_window_size": "1100x800",
  "log_widget_height_percent": 25
}
```

#### Структура secrets.json (конфиденциальные данные)
```json
{
  "OPENROUTER_API_KEY": "your_openrouter_api_key",
  "OPENROUTER_MODEL": "qwen/qwen-2.5-72b-instruct:free",
  
  "SMTP_SERVER": "smtp.gmail.com",
  "SMTP_PORT": 465,
  "SMTP_USER": "your_email@gmail.com",
  "SMTP_PASSWORD": "your_app_password",
  "FROM_EMAIL": "your_email@gmail.com",
  
  "IMAP_SERVER": "imap.gmail.com",
  "IMAP_PORT": 993,
  "IMAP_USER": "your_email@gmail.com",
  "IMAP_PASSWORD": "your_app_password"
}
```

#### Логика загрузки конфигурации в config.py
```python
# Приоритет загрузки:
# 1. secrets.json (высший приоритет)
# 2. Переменные окружения
# 3. settings.json (для не секретных настроек)
# 4. Значения по умолчанию

def _get_setting(name: str, default=None):
    # Проверяем secrets.json
    if name in _SECRETS and _SECRETS.get(name) not in (None, ""):
        return _SECRETS.get(name)
    # Проверяем переменные окружения
    env_value = os.getenv(name)
    if env_value is not None:
        return env_value
    # Проверяем settings.json
    if name.lower() in _SETTINGS:
        return _SETTINGS.get(name.lower())
    return default
```

#### Преимущества разделения
- **Безопасность**: secrets.json в .gitignore, settings.json можно коммитить
- **Простота**: Пользователь может легко настроить UI и поведение
- **Гибкость**: Можно переопределить любую настройку через переменные окружения
- **Поддерживаемость**: Ясное разделение между публичными и приватными настройками

## Детальный план рефакторинга

### Этап 1: Создание упрощенной структуры

#### lib/file_parser.py
```python
def parse_pdf(file_path: str) -> str:
    """Парсит PDF файл, с фоллбэком на OCR."""
    
def parse_excel(file_path: str) -> str:
    """Парсит Excel файл."""
    
def parse_file(file_path: str) -> str:
    """Универсальная функция парсинга."""
```

#### lib/text_processor.py  
```python
def clean_text(text: str) -> str:
    """Очищает и нормализует текст."""
    
def ocr_image(image_path: str) -> str:
    """Простое OCR изображения."""
```

#### lib/llm_client.py
```python
def query_llm(prompt: str, model: str = None) -> str:
    """Простой запрос к LLM."""
    
def extract_invoice_data(text: str) -> dict:
    """Извлекает данные счета через LLM."""
```

#### lib/data_processor.py
```python
def process_files(file_paths: list) -> list:
    """Обрабатывает список файлов."""
    
def compare_invoice_data(app_data: dict, inv_data: dict) -> dict:
    """Сравнивает данные заявки и счета."""
    
def generate_report(comparison: dict) -> str:
    """Генерирует отчет."""
```

### Этап 2: Упрощение GUI

#### gui/main_window.py
```python
class MainWindow(tk.Tk):
    """Главное окно приложения."""
    def __init__(self):
        # Инициализация (до 40 строк)
        
    def setup_layout(self):
        # Настройка layout (до 40 строк)
```

#### gui/file_widgets.py
```python
def create_file_selection_widget(parent) -> tk.Widget:
    """Создает виджет выбора файлов."""

def get_selected_files(widget) -> list:
    """Возвращает выбранные файлы."""
```

### Этап 3: Упрощение логики

#### Убрать сложности
- **Батчинг**: Обрабатывать файлы по одному
- **Пулы воркеров**: Последовательная обработка
- **Сложный retry**: Простой retry с 3 попытками
- **Метрики производительности**: Базовое логирование

#### Оставить простые паттерны
- **Функциональный подход**: Простые функции
- **Базовая обработка ошибок**: try/except с логированием  
- **Простая валидация**: if/else проверки
- **Читаемый код**: Говорящие имена функций

## Ожидаемые результаты

### Преимущества нового подхода
1. **Простота**: Понятная структура из 10 файлов вместо 25+
2. **Читаемость**: Функции до 40 строк, говорящие имена
3. **Поддерживаемость**: Легко найти и изменить любую логику
4. **Надежность**: Простой код = меньше багов

### Сохраняемая функциональность
- ✅ Парсинг PDF/Excel файлов
- ✅ OCR для сложных PDF
- ✅ Извлечение данных через LLM
- ✅ Сравнение заявок и счетов
- ✅ Генерация отчетов
- ✅ Отправка email с вложениями
- ✅ GUI интерфейс
- ✅ Поиск веток в почте

### Новая функциональность
- ➕ **Gmail API интеграция** как основной метод для Google аккаунтов (@gmail.com, G Suite)
- ➕ **Автоматическое определение провайдера** по email домену
- ➕ **Intelligent fallback** на SMTP/IMAP для не-Google серверов
- ➕ **Унифицированный интерфейс** для всех email операций
- ➕ **Улучшенная производительность** Gmail API vs традиционных протоколов
- ➕ **OAuth2 авторизация** для безопасного доступа к Gmail
- ➕ **Расширенные возможности поиска** через Gmail API query language

### Дополнительные зависимости для Gmail API
В requirements.txt:
```
# Существующие зависимости остаются без изменений
# Добавляется:
google-api-python-client>=2.100.0
```

### Настройка Gmail API
1. **Google Cloud Console**: Создать проект, включить Gmail API
2. **OAuth2 Credentials**: Создать credentials для desktop приложения
3. **Скачать client_secret.json** → переименовать в gmail_credentials.json
4. **Настройка в settings.json**:
   ```json
   {
     "gmail_credentials_path": "gmail_credentials.json",
     "gmail_token_path": "gmail_token.json",
     "use_gmail_api": true,
     "google_domains": ["gmail.com", "googlemail.com"]
   }
   ```
5. **Первая авторизация**: Через браузер создаст gmail_token.json автоматически

### Логика выбора метода отправки
```python
# Автоматическое определение
if is_google_account(user_email) and gmail_api_available():
    method = "Gmail API"  # Приоритет
else:
    method = "SMTP/IMAP"  # Fallback
    
# В логах:
"Провайдер: Gmail API (user@gmail.com)" 
"Провайдер: SMTP fallback (user@company.com)"
```

### Убираемые сложности
- ❌ Адаптивный батчинг
- ❌ Пулы воркеров OCR
- ❌ Сложные retry стратегии
- ❌ Метрики производительности
- ❌ Избыточные абстракции
- ❌ Сложная архитектура из 7 пакетов

## Временные затраты

**Оценка**: 2-3 дня работы
- **День 1**: Создание lib/ модулей (6-8 часов)
- **День 2**: Рефакторинг GUI (6-8 часов)  
- **День 3**: Тестирование и отладка (4-6 часов)

## Риски и митигации

### Риск 1: Потеря функциональности
- **Митигация**: Пошаговый рефакторинг с тестированием каждого этапа
- **План**: Сохранить старый код до полного тестирования

### Риск 2: Снижение производительности
- **Митигация**: Для реальных объемов файлов (1-5) разница незаметна
- **План**: При необходимости легко добавить параллелизм

### Риск 3: Усложнение в будущем
- **Митигация**: Простая структура легко расширяется
- **План**: Добавлять сложность только при реальной необходимости

## Требования к детальным таймингам операций

### Обязательное логирование времени выполнения
Все критические операции должны включать детальные тайминги с записью в логи на уровне INFO для мониторинга производительности и в UI статус-сообщения для пользователей.

#### 1. Операции обработки файлов
**Сценарий 1: Один файл заявки + один файл счета**
- **Парсинг файла заявки**: время начала, тип файла, статус успеха, длительность
- **Парсинг файла счета**: время начала, тип файла, использование OCR, длительность
- **LLM обработка**: количество файлов в запросе, время запроса, время ответа, общая длительность
- **Сравнение данных**: время сравнения позиций заявки и счета
- **Генерация отчета**: использование LLM или локального шаблона, длительность

**Сценарий 2: Несколько файлов счетов без заявки**
- **Пакетный парсинг**: количество файлов, время обработки каждого, общее время
- **Параллельная обработка**: использование пула воркеров, эффективность распараллеливания
- **LLM пакетная обработка**: размер батча, время отправки, время получения результата
- **Агрегация результатов**: время валидации и объединения результатов

#### 2. Операции генерации отчетов
**С использованием LLM (флаг включен)**
- **Подготовка промпта**: время формирования запроса с шаблоном
- **LLM запрос**: время отправки промпта, время ожидания ответа
- **Обработка ответа**: время извлечения Markdown из ответа LLM
- **Сохранение отчета**: время записи файла comparison_report.md

**Без LLM (локальная генерация)**
- **Локальная генерация**: время рендеринга Jinja2 шаблона
- **Применение данных**: время подстановки переменных в шаблон
- **Сохранение результата**: время записи готового Markdown файла

#### 3. Операции с электронной почтой

### Gmail API операции (когда используется)
- **Gmail API авторизация**: время OAuth2 процесса
- **Gmail API отправка**: время отправки письма через API
- **Gmail API поиск**: время поиска писем через API

### SMTP/IMAP операции (когда используется)
- **SMTP отправка**: время отправки через SMTP
- **IMAP поиск**: время поиска через IMAP

**Формат логирования:**
```
[INFO] Операция 'gmail_api_отправка' завершена за 2.345с
[INFO] Операция 'smtp_отправка' завершена за 3.456с
[INFO] Операция 'gmail_api_поиск' завершена за 1.234с
[INFO] Операция 'imap_поиск' завершена за 4.567с
```

#### 4. UI операции и взаимодействие
**Переключение чекбокса "Переделка"**
- **Синхронизация темы**: время добавления/удаления постфикса в поле темы
- **Валидация состояния**: время проверки доступности чекбокса
- **Обновление UI**: время перерисовки элементов

**Заполнение полей письма по умолчанию**
- **Извлечение данных**: время получения информации из результатов LLM
- **Формирование темы**: время создания строки с поставщиком, номером, заказчиком
- **Формирование тела**: время создания сообщения с изделием и суммой
- **Обновление вложений**: время добавления исходных файлов счетов

**Переименование папки заказа после отправки**
- **Очистка файлов**: время удаления сгенерированных файлов приложения
- **Переименование**: время добавления метки "Оплата" к имени папки
- **Обновление контекста**: время смены рабочей директории и обновления GUI

#### 5. Формат логирования таймингов
```
[INFO] [timestamp] | Операция 'парсинг_pdf' начата | файл: invoice_001.pdf
[INFO] [timestamp] | Операция 'парсинг_pdf' завершена за 2.345с | файл: invoice_001.pdf, тип: PDF, ocr: нет
[INFO] [timestamp] | Операция 'llm_обработка' начата | файлов: 2, модель: qwen/qwen-2.5-72b-instruct:free
[INFO] [timestamp] | Операция 'llm_обработка' завершена за 15.678с | файлов: 2, результатов: 2, успех: да
[INFO] [timestamp] | Операция 'отправка_письма' завершена за 3.456с | получатель: user@example.com, вложений: 3, размер: 2.5MB
[INFO] [timestamp] | Операция 'поиск_веток' завершена за 4.123с | получатель: user@example.com, найдено: 5 писем
```

#### 6. UI статус-сообщения с таймингами
- "Обработка файлов завершена за 8.2с"
- "Найдено 5 писем за 2.1с"
- "Отчет сгенерирован за 1.5с (локально)" / "Отчет сгенерирован за 12.3с (LLM)"
- "Письмо отправлено за 3.8с с 3 вложениями"
- "Папка переименована за 0.5с"

### Детали реализации
1. **Использовать PerformanceLogger** для всех таймингов с дополнительными метаданными
2. **Начинать таймер** в начале каждой критической операции
3. **Заканчивать таймер** с записью результата и контекстной информации
4. **Обновлять UI статус** с информацией о длительности операций
5. **Логировать на уровне INFO** для операционного мониторинга
6. **Включать контекст**: файлы, размеры, количества, статусы успеха

## Выводы

Текущий проект страдает от **over-engineering** — решение простой задачи сложными средствами. Предлагаемый рефакторинг:

1. **Упростит архитектуру** с 7 пакетов до 2
2. **Улучшит читаемость** — функции до 40 строк
3. **Повысит поддерживаемость** — понятная структура
4. **Сохранит всю функциональность** — пользователь не заметит разницы
5. **Соответствует принципам KISS** — максимальная простота
6. **Добавит детальные тайминги** — полная прозрачность производительности

Это будет **качественный рефакторинг**, который сделает код проще, читаемее и надежнее, следуя всем принципам из conventions.mdc, с добавлением полного мониторинга производительности всех операций.